/*
 * generated by Xtext 2.25.0
 */
package io.github.forsyde.io.serializer;

import com.google.inject.Inject;
import io.github.forsyde.io.meta.EdgeTrait;
import io.github.forsyde.io.meta.EdgeTraitConstraint;
import io.github.forsyde.io.meta.MetaPackage;
import io.github.forsyde.io.meta.Model;
import io.github.forsyde.io.meta.VertexTrait;
import io.github.forsyde.io.meta.VertexTraitArrayProperty;
import io.github.forsyde.io.meta.VertexTraitBoolProperty;
import io.github.forsyde.io.meta.VertexTraitIntProperty;
import io.github.forsyde.io.meta.VertexTraitObjectProperty;
import io.github.forsyde.io.meta.VertexTraitPort;
import io.github.forsyde.io.meta.VertexTraitProperty;
import io.github.forsyde.io.meta.VertexTraitRealProperty;
import io.github.forsyde.io.meta.VertexTraitStringProperty;
import io.github.forsyde.io.services.MetaGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MetaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MetaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MetaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MetaPackage.EDGE_TRAIT:
				sequence_EdgeTrait(context, (EdgeTrait) semanticObject); 
				return; 
			case MetaPackage.EDGE_TRAIT_CONSTRAINT:
				sequence_EdgeTraitConstraint(context, (EdgeTraitConstraint) semanticObject); 
				return; 
			case MetaPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT:
				sequence_VertexTrait(context, (VertexTrait) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_ARRAY_PROPERTY:
				sequence_VertexTraitArrayProperty(context, (VertexTraitArrayProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_BOOL_PROPERTY:
				sequence_VertexTraitBoolProperty(context, (VertexTraitBoolProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_INT_PROPERTY:
				sequence_VertexTraitIntProperty(context, (VertexTraitIntProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_OBJECT_PROPERTY:
				sequence_VertexTraitObjectProperty(context, (VertexTraitObjectProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_PORT:
				sequence_VertexTraitPort(context, (VertexTraitPort) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_PROPERTY:
				sequence_VertexTraitProperty(context, (VertexTraitProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_REAL_PROPERTY:
				sequence_VertexTraitRealProperty(context, (VertexTraitRealProperty) semanticObject); 
				return; 
			case MetaPackage.VERTEX_TRAIT_STRING_PROPERTY:
				sequence_VertexTraitStringProperty(context, (VertexTraitStringProperty) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EdgeTraitConstraint returns EdgeTraitConstraint
	 *
	 * Constraint:
	 *     ((target?='target' | source?='source') filter+=[VertexTrait|ID] filter+=[VertexTrait|ID]*)
	 */
	protected void sequence_EdgeTraitConstraint(ISerializationContext context, EdgeTraitConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EdgeTrait returns EdgeTrait
	 *
	 * Constraint:
	 *     (name=ID (refines+=[EdgeTrait|ID] refines+=[EdgeTrait|ID]*)? specs+=EdgeTraitConstraint*)
	 */
	protected void sequence_EdgeTrait(ISerializationContext context, EdgeTrait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (traits+=VertexTrait | traits+=EdgeTrait)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitArrayProperty
	 *     VertexTraitArrayProperty returns VertexTraitArrayProperty
	 *
	 * Constraint:
	 *     itemType=VertexTraitPropertyType
	 */
	protected void sequence_VertexTraitArrayProperty(ISerializationContext context, VertexTraitArrayProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_ARRAY_PROPERTY__ITEM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_ARRAY_PROPERTY__ITEM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitArrayPropertyAccess().getItemTypeVertexTraitPropertyTypeParserRuleCall_2_0(), semanticObject.getItemType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitBoolProperty
	 *     VertexTraitBoolProperty returns VertexTraitBoolProperty
	 *
	 * Constraint:
	 *     default?='true'
	 */
	protected void sequence_VertexTraitBoolProperty(ISerializationContext context, VertexTraitBoolProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_BOOL_PROPERTY__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_BOOL_PROPERTY__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitBoolPropertyAccess().getDefaultTrueKeyword_1_1_0(), semanticObject.isDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitIntProperty
	 *     VertexTraitIntProperty returns VertexTraitIntProperty
	 *
	 * Constraint:
	 *     default=INT
	 */
	protected void sequence_VertexTraitIntProperty(ISerializationContext context, VertexTraitIntProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_INT_PROPERTY__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_INT_PROPERTY__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitIntPropertyAccess().getDefaultINTTerminalRuleCall_1_1_0(), semanticObject.getDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitObjectProperty
	 *     VertexTraitObjectProperty returns VertexTraitObjectProperty
	 *
	 * Constraint:
	 *     (keyType=VertexTraitPropertyType valueType=VertexTraitPropertyType)
	 */
	protected void sequence_VertexTraitObjectProperty(ISerializationContext context, VertexTraitObjectProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_OBJECT_PROPERTY__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_OBJECT_PROPERTY__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_OBJECT_PROPERTY__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_OBJECT_PROPERTY__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitObjectPropertyAccess().getKeyTypeVertexTraitPropertyTypeParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getVertexTraitObjectPropertyAccess().getValueTypeVertexTraitPropertyTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPort returns VertexTraitPort
	 *
	 * Constraint:
	 *     (multiple?='multiple' | ordered?='ordered' | (direction=VertexTraitPortDirection? name=ID trait=[VertexTrait|ID]))+
	 */
	protected void sequence_VertexTraitPort(ISerializationContext context, VertexTraitPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitProperty returns VertexTraitProperty
	 *
	 * Constraint:
	 *     (name=ID type=VertexTraitPropertyType)
	 */
	protected void sequence_VertexTraitProperty(ISerializationContext context, VertexTraitProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_PROPERTY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_PROPERTY__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitPropertyAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVertexTraitPropertyAccess().getTypeVertexTraitPropertyTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitRealProperty
	 *     VertexTraitRealProperty returns VertexTraitRealProperty
	 *
	 * Constraint:
	 *     ((double?='double' default=STRING) | default=STRING)?
	 */
	protected void sequence_VertexTraitRealProperty(ISerializationContext context, VertexTraitRealProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VertexTraitPropertyType returns VertexTraitStringProperty
	 *     VertexTraitStringProperty returns VertexTraitStringProperty
	 *
	 * Constraint:
	 *     default=STRING
	 */
	protected void sequence_VertexTraitStringProperty(ISerializationContext context, VertexTraitStringProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_STRING_PROPERTY__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MetaPackage.Literals.VERTEX_TRAIT_STRING_PROPERTY__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVertexTraitStringPropertyAccess().getDefaultSTRINGTerminalRuleCall_1_1_0(), semanticObject.getDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VertexTrait returns VertexTrait
	 *
	 * Constraint:
	 *     (name=ID (refines+=[VertexTrait|ID] refines+=[VertexTrait|ID]*)? ports+=VertexTraitPort* properties+=VertexTraitProperty*)
	 */
	protected void sequence_VertexTrait(ISerializationContext context, VertexTrait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
