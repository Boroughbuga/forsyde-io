buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.squareup:javapoet:1.13.0'
        classpath group: 'org.jgrapht', name: 'jgrapht-core', version: '1.5.0'
    }
}

import groovy.json.JsonSlurper
import javax.lang.model.element.Modifier
import java.util.Optional

import com.squareup.javapoet.TypeSpec
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.JavaFile

import org.jgrapht.*
import org.jgrapht.graph.*
import org.jgrapht.traverse.*

task generateVertexTraits {
    def modelStr = file('meta.json').text
    def traitClass = ClassName.get('forsyde.io.java.core', 'Trait')
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (vertexTrait in model['vertexTraits']) {
        traitGraph.addVertex(vertexTrait.key)
    }
    for (vertexTrait in model['vertexTraits']) {
        if (vertexTrait.value) {
            for (superTrait in vertexTrait.value['superTraits']) {
                traitGraph.addEdge(vertexTrait.key, superTrait)
            }
        }
    }
    // now spit the LUTs for the enums
    def vertexEnum = TypeSpec.enumBuilder('VertexTrait')
        .addSuperinterface(traitClass)
        .addModifiers(Modifier.PUBLIC)
    // refinement method
    def refinesMethod = MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'VertexTrait'), 'one')
        .addParameter(ClassName.get('forsyde.io.java.core', 'VertexTrait'), 'other')
        .beginControlFlow('switch (one)')
    for (vertexTrait in model['vertexTraits']) {
        vertexEnum.addEnumConstant(vertexTrait.key)
        refinesMethod.addCode('case ' + vertexTrait.key + ':\n')
        refinesMethod.beginControlFlow('switch (other)')
        def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, vertexTrait.key)
        while (superIterator.hasNext()) {
            def superTrait = superIterator.next()
            refinesMethod.addCode('case ' + superTrait + ': ')
            refinesMethod.addStatement('return true')
        }
        refinesMethod.addStatement('default: return false')
        refinesMethod.endControlFlow()
    }
    refinesMethod.addStatement('default: return false')
    refinesMethod.endControlFlow()
    vertexEnum.addMethod(refinesMethod.build())
    vertexEnum.addMethod(
        MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'Trait'), 'other')
        .addStatement('return other instanceof VertexTrait ? VertexTrait.refines(this, (VertexTrait) other) : false')
        .build()
    )
    vertexEnum.addMethod(
        MethodSpec.methodBuilder('getName')
        .returns(ClassName.bestGuess('java.lang.String'))
        .addModifiers(Modifier.PUBLIC)
        .addStatement('return this.toString()')
        .build()
    )
    // write down these nice generated enums
    def fileStr = JavaFile.builder('forsyde.io.java.core', vertexEnum.build())
    file('src-gen/main/java/forsyde/io/java/core').mkdirs()
    file('src-gen/main/java/forsyde/io/java/core/VertexTrait.java').text = fileStr.build()
}

task generateEdgeTraits {
    def modelStr = file('meta.json').text
    def traitClass = ClassName.get('forsyde.io.java.core', 'Trait')
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (edgeTrait in model['edgeTraits']) {
        traitGraph.addVertex(edgeTrait.key)
    }
    for (edgeTrait in model['edgeTraits']) {
        if (edgeTrait.value) {
            for (superTrait in edgeTrait.value['superTraits']) {
                traitGraph.addEdge(edgeTrait.key, superTrait)
            }
        }
    }
    // now spit the LUTs for the enums
    def edgeEnum = TypeSpec.enumBuilder('EdgeTrait')
        .addSuperinterface(traitClass)
        .addModifiers(Modifier.PUBLIC)
    def refinesMethod = MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'EdgeTrait'), 'one')
        .addParameter(ClassName.get('forsyde.io.java.core', 'EdgeTrait'), 'other')
        .beginControlFlow('switch (one)')
    for (edgeTrait in model['edgeTraits']) {
        edgeEnum.addEnumConstant(edgeTrait.key)
        refinesMethod.addCode('case ' + edgeTrait.key + ':\n')
        refinesMethod.beginControlFlow('switch (other)')
        def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, edgeTrait.key)
        while (superIterator.hasNext()) {
            def superTrait = superIterator.next()
            refinesMethod.addCode('case ' + superTrait + ': ')
            refinesMethod.addStatement('return true')
        }
        refinesMethod.addStatement('default: return false')
        refinesMethod.endControlFlow()
    }
    refinesMethod.addStatement('default: return false')
    refinesMethod.endControlFlow()
    edgeEnum.addMethod(refinesMethod.build())
    edgeEnum.addMethod(
        MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'Trait'), 'other')
        .addStatement('return other instanceof EdgeTrait ? EdgeTrait.refines(this, (EdgeTrait) other) : false')
        .build()
    )
    edgeEnum.addMethod(
        MethodSpec.methodBuilder('getName')
        .returns(ClassName.bestGuess('java.lang.String'))
        .addModifiers(Modifier.PUBLIC)
        .addStatement('return this.toString()')
        .build()
    )
    // write down these nice generated enums
    def fileStr = JavaFile.builder('forsyde.io.java.core', edgeEnum.build())
    file('src-gen/main/java/forsyde/io/java/core').mkdirs()
    file('src-gen/main/java/forsyde/io/java/core/EdgeTrait.java').text = fileStr.build()
}

// https://gist.github.com/two7sclash/c3835d83695b46ca2a6a4b6d71272538, with corrections
def toCamelCase(String text, boolean capitalized=false ) {
    text = text.replaceAll( '(_)([A-Za-z0-9])', { Object[] it -> it[2].toUpperCase() } )
    return capitalized ? text.capitalize() : text
}

def metaToJavaType(md) {
    if (md['class'] == 'object') {
        return ParameterizedTypeName.get(ClassName.get(Map.class), metaToJavaType(md.key), metaToJavaType(md.value))
    }
    else if (md['class'] == 'array') {
        return ParameterizedTypeName.get(ClassName.get(List.class), metaToJavaType(md.value))
    }
    else if (md['class'] == 'int' || md['class'] == 'integer') {
        return ClassName.get(Integer.class)
    }
    else if (md['class'] == 'double') {
        return ClassName.get(Double.class)
    }
    else if (md['class'] == 'float') {
        return ClassName.get(Float.class)
    }
    else if (md['class'] == 'boolean' || md['class'] == 'bool') {
        return ClassName.get(Boolean.class)
    }
    else
        return ClassName.get(String.class)
}

task generateVertexAcessor(dependsOn: [generateVertexTraits]) {
    def modelStr = file('meta.json').text
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (vertexTrait in model['vertexTraits']) {
        traitGraph.addVertex(vertexTrait.key)
    }
    for (vertexTrait in model['vertexTraits']) {
        if (vertexTrait.value) {
            for (superTrait in vertexTrait.value['superTraits']) {
                traitGraph.addEdge(vertexTrait.key, superTrait)
            }
        }
    }

    // def accessGenerated = []
    for (vertexTrait in model['vertexTraits']) {
		def className = vertexTrait.key + 'Acessor'
        def acessorClass = TypeSpec.classBuilder(className)
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
        if (vertexTrait.value) {
			def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, vertexTrait.key)
            for (traitName in superIterator) {
				def currentTrait = model['vertexTraits'][traitName]
				if (currentTrait != null) {
					for(vertexProp in currentTrait['required_properties']) {
						// accessGenerated.add(vertexProp.key)
						def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), metaToJavaType(vertexProp.value))
						def getPropMethod = MethodSpec.methodBuilder('get' + toCamelCase(vertexProp.key, true))
							.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
							.addParameter(ClassName.get('forsyde.io.java.core', 'Vertex'), "vertex")
							.returns(optionalOut)
						getPropMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexProp.key + "\"))")
						getPropMethod.addStatement('return Optional.of((' + metaToJavaType(vertexProp.value).toString() + ") vertex.properties.get(\"" + vertexProp.key + "\"))")
						getPropMethod.nextControlFlow('else')
						getPropMethod.addStatement('return Optional.empty()')
						getPropMethod.endControlFlow()
						acessorClass.addMethod(getPropMethod.build())
					}
					for(vertexPort in currentTrait['required_ports']) {
						// accessGenerated.add(vertexPort.key)
						def vertexClass = ClassName.get('forsyde.io.java.core', 'Vertex')
						def listOut = ParameterizedTypeName.get(ClassName.get(List.class), vertexClass)
						def setOut = ParameterizedTypeName.get(ClassName.get(Set.class), vertexClass)
						def getPortMethod = MethodSpec.methodBuilder('get' + toCamelCase(vertexPort.key + 'Port', true))
							.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
							.addParameter(ClassName.get('forsyde.io.java.core', 'ForSyDeModel'), "model")
							.addParameter(vertexClass, "vertex")
						if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered") {
							def arrayType = ParameterizedTypeName.get(ClassName.get(ArrayList.class), vertexClass)
							getPortMethod.addStatement('$T outList = new $T()', arrayType, arraType)
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] >= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.outgoingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.sourcePort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('outList.add(e.target)')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] <= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.incomingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.targetPort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('outList.add(e.source)')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							getPortMethod.addStatement('return outList')
							getPortMethod.returns(listOut)
						} else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered") {
							def setType = ParameterizedTypeName.get(ClassName.get(HashSet.class), vertexClass)
							getPortMethod.addStatement('$T outList = new $T()', setType, setType)
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] >= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.outgoingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.sourcePort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('outList.add(e.target)')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] <= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.incomingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.targetPort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('outList.add(e.source)')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							getPortMethod.addStatement('return outList')
							getPortMethod.returns(setOut)
						} else {
							getPortMethod.returns(vertexOut)
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] >= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.outgoingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.sourcePort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('return e.target')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							if (vertexPort.value['direction'] != null && vertexPort.value['direction'] <= 0) {
								getPortMethod.beginControlFlow('for ($T e: model.incomingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
								getPortMethod.beginControlFlow("if (e.targetPort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
								getPortMethod.addStatement('return e.source')
								getPortMethod.endControlFlow()	
								getPortMethod.endControlFlow()	
							}
							getPortMethod.addStatement('return null')
						}
						// getPortMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexPort.key + "\"))")
						// getPortMethod.addStatement('return Optional.of((' + metaToJavaType(vertexPort.value).toString() + ") vertex.properties.get(\"" + vertexPort.key + "\"))")
						// getPortMethod.nextControlFlow('else')
						// getPortMethod.endControlFlow()
						acessorClass.addMethod(getPortMethod.build())
					}
				}
            }
        }
		def getPropMethod = MethodSpec
			.methodBuilder('is' + toCamelCase(vertexTrait.key, true))
			.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
			.addParameter(ClassName.get('forsyde.io.java.core', 'Vertex'), 'vertex')
			.returns(ClassName.get(Boolean.class))
        def fileStr = JavaFile.builder('forsyde.io.java.typed.acessor', acessorClass.build())
        file('src-gen/main/java/forsyde/io/java/typed/acessor').mkdirs()
        file('src-gen/main/java/forsyde/io/java/typed/acessor/' + className + '.java').text = fileStr.build()
    }
// write down these nice generated enums
}
