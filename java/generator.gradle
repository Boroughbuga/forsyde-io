buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.squareup:javapoet:1.13.0'
        classpath group: 'org.jgrapht', name: 'jgrapht-core', version: '1.5.0'
    }
}

import groovy.json.JsonSlurper
import javax.lang.model.element.Modifier
import java.util.Optional

import com.squareup.javapoet.TypeSpec
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.JavaFile

import org.jgrapht.*
import org.jgrapht.graph.*
import org.jgrapht.traverse.*

task generateVertexTraits {
    def modelStr = file('meta.json').text
    def traitClass = ClassName.get('forsyde.io.java.core', 'Trait')
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (vertexTrait in model['vertexTraits']) {
        traitGraph.addVertex(vertexTrait.key)
    }
    for (vertexTrait in model['vertexTraits']) {
        if (vertexTrait.value) {
            for (superTrait in vertexTrait.value['superTraits']) {
                traitGraph.addEdge(vertexTrait.key, superTrait)
            }
        }
    }
    // now spit the LUTs for the enums
    def vertexEnum = TypeSpec.enumBuilder('VertexTrait')
        .addSuperinterface(traitClass)
        .addModifiers(Modifier.PUBLIC)
    // refinement method
    def refinesMethod = MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'VertexTrait'), 'one')
        .addParameter(ClassName.get('forsyde.io.java.core', 'VertexTrait'), 'other')
        .beginControlFlow('switch (one)')
    for (vertexTrait in model['vertexTraits']) {
        vertexEnum.addEnumConstant(vertexTrait.key)
        refinesMethod.addCode('case ' + vertexTrait.key + ':\n')
        refinesMethod.beginControlFlow('switch (other)')
        def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, vertexTrait.key)
        while (superIterator.hasNext()) {
            def superTrait = superIterator.next()
            refinesMethod.addCode('case ' + superTrait + ': ')
            refinesMethod.addStatement('return true')
        }
        refinesMethod.addStatement('default: return false')
        refinesMethod.endControlFlow()
    }
    refinesMethod.addStatement('default: return false')
    refinesMethod.endControlFlow()
    vertexEnum.addMethod(refinesMethod.build())
    vertexEnum.addMethod(
        MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'Trait'), 'other')
        .addStatement('return other instanceof VertexTrait ? VertexTrait.refines(this, (VertexTrait) other) : false')
        .build()
    )
    vertexEnum.addMethod(
        MethodSpec.methodBuilder('getName')
        .returns(ClassName.bestGuess('java.lang.String'))
        .addModifiers(Modifier.PUBLIC)
        .addStatement('return this.toString()')
        .build()
    )
    // write down these nice generated enums
    def fileStr = JavaFile.builder('forsyde.io.java.core', vertexEnum.build())
    file('src-gen/main/java/forsyde/io/java/core').mkdirs()
    file('src-gen/main/java/forsyde/io/java/core/VertexTrait.java').text = fileStr.build()
}

task generateEdgeTraits {
    def modelStr = file('meta.json').text
    def traitClass = ClassName.get('forsyde.io.java.core', 'Trait')
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (edgeTrait in model['edgeTraits']) {
        traitGraph.addVertex(edgeTrait.key)
    }
    for (edgeTrait in model['edgeTraits']) {
        if (edgeTrait.value) {
            for (superTrait in edgeTrait.value['superTraits']) {
                traitGraph.addEdge(edgeTrait.key, superTrait)
            }
        }
    }
    // now spit the LUTs for the enums
    def edgeEnum = TypeSpec.enumBuilder('EdgeTrait')
        .addSuperinterface(traitClass)
        .addModifiers(Modifier.PUBLIC)
    def refinesMethod = MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'EdgeTrait'), 'one')
        .addParameter(ClassName.get('forsyde.io.java.core', 'EdgeTrait'), 'other')
        .beginControlFlow('switch (one)')
    for (edgeTrait in model['edgeTraits']) {
        edgeEnum.addEnumConstant(edgeTrait.key)
        refinesMethod.addCode('case ' + edgeTrait.key + ':\n')
        refinesMethod.beginControlFlow('switch (other)')
        def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, edgeTrait.key)
        while (superIterator.hasNext()) {
            def superTrait = superIterator.next()
            refinesMethod.addCode('case ' + superTrait + ': ')
            refinesMethod.addStatement('return true')
        }
        refinesMethod.addStatement('default: return false')
        refinesMethod.endControlFlow()
    }
    refinesMethod.addStatement('default: return false')
    refinesMethod.endControlFlow()
    edgeEnum.addMethod(refinesMethod.build())
    edgeEnum.addMethod(
        MethodSpec.methodBuilder('refines')
        .returns(TypeName.BOOLEAN)
        .addModifiers(Modifier.PUBLIC)
        .addParameter(ClassName.get('forsyde.io.java.core', 'Trait'), 'other')
        .addStatement('return other instanceof EdgeTrait ? EdgeTrait.refines(this, (EdgeTrait) other) : false')
        .build()
    )
    edgeEnum.addMethod(
        MethodSpec.methodBuilder('getName')
        .returns(ClassName.bestGuess('java.lang.String'))
        .addModifiers(Modifier.PUBLIC)
        .addStatement('return this.toString()')
        .build()
    )
    // write down these nice generated enums
    def fileStr = JavaFile.builder('forsyde.io.java.core', edgeEnum.build())
    file('src-gen/main/java/forsyde/io/java/core').mkdirs()
    file('src-gen/main/java/forsyde/io/java/core/EdgeTrait.java').text = fileStr.build()
}

// https://gist.github.com/two7sclash/c3835d83695b46ca2a6a4b6d71272538, with corrections
def toCamelCase(String text, boolean capitalized=false ) {
    text = text.replaceAll( '(_)([A-Za-z0-9])', { Object[] it -> it[2].toUpperCase() } )
    return capitalized ? text.capitalize() : text
}

def metaToJavaType(md) {
    if (md['class'] == 'object') {
        return ParameterizedTypeName.get(ClassName.get(Map.class), metaToJavaType(md.key), metaToJavaType(md.value))
    }
    else if (md['class'] == 'array') {
        return ParameterizedTypeName.get(ClassName.get(List.class), metaToJavaType(md.value))
    }
    else if (md['class'] == 'int' || md['class'] == 'integer') {
        return ClassName.get(Integer.class)
    }
    else if (md['class'] == 'double') {
        return ClassName.get(Double.class)
    }
    else if (md['class'] == 'float') {
        return ClassName.get(Float.class)
    }
    else if (md['class'] == 'boolean' || md['class'] == 'bool') {
        return ClassName.get(Boolean.class)
    }
    else
        return ClassName.get(String.class)
}

task generateVertexInterfaces(dependsOn: [generateVertexTraits]) {
    def modelStr = file('meta.json').text
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    for (vertexTrait in model['vertexTraits']) {
        traitGraph.addVertex(vertexTrait.key)
    }
    for (vertexTrait in model['vertexTraits']) {
        if (vertexTrait.value) {
            for (superTrait in vertexTrait.value['superTraits']) {
                traitGraph.addEdge(vertexTrait.key, superTrait)
            }
        }
    }

    for (vertexTrait in model['vertexTraits']) {
		def className = vertexTrait.key
        def acessorClass = TypeSpec.interfaceBuilder(className)
            .addModifiers(Modifier.PUBLIC)
            .addSuperinterface(ClassName.get("forsyde.io.java.core", "VertexInterface"))
        if (vertexTrait.value) {
			def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, vertexTrait.key)
            def currentTrait = model['vertexTraits'][superIterator.next()]
            for(vertexProp in currentTrait['required_properties']) {
                // accessGenerated.add(vertexProp.key)
                def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), metaToJavaType(vertexProp.value))
                def getPropMethod = MethodSpec.methodBuilder('get' + toCamelCase(vertexProp.key, true))
                    .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
                    .returns(metaToJavaType(vertexProp.value))
                getPropMethod.addStatement('return (' + metaToJavaType(vertexProp.value).toString() + ") getProperties().get(\"" + vertexProp.key + "\").unwrap()")
                acessorClass.addMethod(getPropMethod.build())
            }
            // port acessors are generated depending in the multiplicity of their connections and possible directions
            for(vertexPort in currentTrait['required_ports']) {
                // accessGenerated.add(vertexPort.key)
                def vertexClass = ClassName.get('forsyde.io.java.core', 'VertexInterface')
                def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), vertexClass)
                def listOut = ParameterizedTypeName.get(ClassName.get(List.class), vertexClass)
                def setOut = ParameterizedTypeName.get(ClassName.get(Set.class), vertexClass)
                def arrayType = ParameterizedTypeName.get(ClassName.get(ArrayList.class), vertexClass)
                def setType = ParameterizedTypeName.get(ClassName.get(HashSet.class), vertexClass)
                def getPortName = 'get' + toCamelCase(vertexPort.key + 'Port', true)
                def getPortMethod = MethodSpec.methodBuilder(getPortName)
                    .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
                    .addParameter(ClassName.get('forsyde.io.java.core', 'ForSyDeModel'), "model")
                    // .addParameter(vertexClass, "vertex")
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getPortMethod.returns(arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getPortMethod.returns(setType)
                else
                    getPortMethod.returns(optionalOut)
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getPortMethod.returns(arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getPortMethod.returns(setType)
                else
                    getPortMethod.returns(optionalOut)
                // decide if a collection needs to be generated
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getPortMethod.addStatement('$T outList = new $T()', arrayType, arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getPortMethod.addStatement('$T outList = new $T()', setType, setType)
                // generate the iteration to collect or find vertexes
                if (vertexPort.value['direction'] == null || (vertexPort.value['direction'] != null && vertexPort.value['direction'] >= 0)) {
                        getPortMethod.beginControlFlow('for ($T e: model.outgoingEdgesOf(this))', ClassName.get('forsyde.io.java.core', 'EdgeInterface'))
                        getPortMethod.beginControlFlow("if (e.getSourcePort().orElse(\"\").equals(\"" + vertexPort.key + "\"))")
                        // this decides for every iteration if first found is good or if a list is being built.
                        if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                            getPortMethod.addStatement('outList.add(e.getTarget())')
                        else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                            getPortMethod.addStatement('outList.add(e.getTarget())')
                        else
                            getPortMethod.addStatement('return Optional.of(e.getTarget())')
                        getPortMethod.endControlFlow()	
                        getPortMethod.endControlFlow()	
                }
                if (vertexPort.value['direction'] == null || (vertexPort.value['direction'] != null && vertexPort.value['direction'] <= 0)) {
                        getPortMethod.beginControlFlow('for ($T e: model.incomingEdgesOf(this))', ClassName.get('forsyde.io.java.core', 'EdgeInterface'))
                        getPortMethod.beginControlFlow("if (e.getTargetPort().orElse(\"\").equals(\"" + vertexPort.key + "\"))")
                        // this decides for every iteration if first found is good or if a list is being built.
                        if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                            getPortMethod.addStatement('outList.add(e.getSource())')
                        else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                            getPortMethod.addStatement('outList.add(e.getSource())')
                        else
                            getPortMethod.addStatement('return Optional.of(e.getSource())')
                        getPortMethod.endControlFlow()	
                        getPortMethod.endControlFlow()	
                }
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getPortMethod.addStatement("return outList")
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getPortMethod.addStatement("return outList")
                else
                    getPortMethod.addStatement("return Optional.empty()")
                // getPortMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexPort.key + "\"))")
                // getPortMethod.addStatement('return Optional.of((' + metaToJavaType(vertexPort.value).toString() + ") vertex.properties.get(\"" + vertexPort.key + "\"))")
                // getPortMethod.nextControlFlow('else')
                // getPortMethod.endControlFlow()
                acessorClass.addMethod(getPortMethod.build())
            }
            for (traitName in vertexTrait.value['superTraits']) {
                acessorClass.addSuperinterface(ClassName.get("forsyde.io.java.typed.interfaces", traitName))
            }
        }
        def conformsMethod = MethodSpec
			.methodBuilder('conforms')
			.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
			.addParameter(ClassName.get('forsyde.io.java.core', 'VertexInterface'), 'vertex')
			.returns(ClassName.get(Boolean.class))
        conformsMethod.addStatement('return vertex.getTraits().contains($T.' + vertexTrait.key + ')', ClassName.get('forsyde.io.java.core', "VertexTrait"))
        acessorClass.addMethod(conformsMethod.build())
        def fileStr = JavaFile.builder('forsyde.io.java.typed.interfaces', acessorClass.build())
        file('src-gen/main/java/forsyde/io/java/typed/interfaces').mkdirs()
        file('src-gen/main/java/forsyde/io/java/typed/interfaces/' + className + '.java').text = fileStr.build()
    }
}

task generateVertexConcreteClasses(dependsOn: [generateVertexInterfaces]) {
    def modelStr = file('meta.json').text
    def model = new JsonSlurper().parseText(modelStr)
    // first build the trait graph
    def traitGraph = new SimpleDirectedGraph<String, DefaultEdge>(DefaultEdge.class)
    def accessGenerated = [:]
    for (vertexTrait in model['vertexTraits']) {
        traitGraph.addVertex(vertexTrait.key)
    }
    for (vertexTrait in model['vertexTraits']) {
        if (vertexTrait.value) {
            for (superTrait in vertexTrait.value['superTraits']) {
                traitGraph.addEdge(vertexTrait.key, superTrait)
            }
        }
    }

    for (vertexTrait in model['vertexTraits']) {
		def className = vertexTrait.key + 'Prototype'
        def acessorClass = TypeSpec.classBuilder(className)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .superclass(ClassName.get("forsyde.io.java.core", "Vertex"))
            .addSuperinterface(ClassName.get("forsyde.io.java.typed.interfaces", 'I' + vertexTrait.key))
        if (vertexTrait.value) {
			def superIterator = new DepthFirstIterator<String, DefaultEdge>(traitGraph, vertexTrait.key)
            def currentTrait = model['vertexTraits'][superIterator.next()]
            for(vertexProp in currentTrait['required_properties']) {
                // accessGenerated.add(vertexProp.key)
                def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), metaToJavaType(vertexProp.value))
                def getStaticPropMethod = MethodSpec.methodBuilder('staticGet' + toCamelCase(vertexProp.key, true))
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                    .addParameter(ClassName.get('forsyde.io.java.core', 'Vertex'), "vertex")
                    .returns(metaToJavaType(vertexProp.value))
                getStaticPropMethod.addStatement('return (' + metaToJavaType(vertexProp.value).toString() + ") vertex.properties.get(\"" + vertexProp.key + "\").unwrap()")
                acessorClass.addMethod(getStaticPropMethod.build())
                def getPropMethod = MethodSpec.methodBuilder('get' + toCamelCase(vertexProp.key, true))
                    .addModifiers(Modifier.PUBLIC)
                    .returns(metaToJavaType(vertexProp.value))
                getPropMethod.addStatement('return staticGet' + toCamelCase(vertexProp.key, true) + '(this)')
                acessorClass.addMethod(getPropMethod.build())
            }
            // port acessors are generated depending in the multiplicity of their connections and possible directions
            for(vertexPort in currentTrait['required_ports']) {
                // accessGenerated.add(vertexPort.key)
                def vertexClass = ClassName.get('forsyde.io.java.core', 'Vertex')
                def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), vertexClass)
                def listOut = ParameterizedTypeName.get(ClassName.get(List.class), vertexClass)
                def setOut = ParameterizedTypeName.get(ClassName.get(Set.class), vertexClass)
                def arrayType = ParameterizedTypeName.get(ClassName.get(ArrayList.class), vertexClass)
                def setType = ParameterizedTypeName.get(ClassName.get(HashSet.class), vertexClass)
                def getStaticPortName = 'staticGet' + toCamelCase(vertexPort.key + 'Port', true)
                def getStaticPortMethod = MethodSpec.methodBuilder(getStaticPortName)
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                    .addParameter(ClassName.get('forsyde.io.java.core', 'ForSyDeModel'), "model")
                    .addParameter(vertexClass, "vertex")
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getStaticPortMethod.returns(arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getStaticPortMethod.returns(setType)
                else
                    getStaticPortMethod.returns(optionalOut)
                // decide if a collection needs to be generated
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getStaticPortMethod.addStatement('$T outList = new $T()', arrayType, arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getStaticPortMethod.addStatement('$T outList = new $T()', setType, setType)
                // generate the iteration to collect or find vertexes
                if (vertexPort.value['direction'] == null || (vertexPort.value['direction'] != null && vertexPort.value['direction'] >= 0)) {
                        getStaticPortMethod.beginControlFlow('for ($T e: model.outgoingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
                        getStaticPortMethod.beginControlFlow("if (e.sourcePort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
                        // this decides for every iteration if first found is good or if a list is being built.
                        if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                            getStaticPortMethod.addStatement('outList.add(e.target)')
                        else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                            getStaticPortMethod.addStatement('outList.add(e.target)')
                        else
                            getStaticPortMethod.addStatement('return Optional.of(e.target)')
                        getStaticPortMethod.endControlFlow()	
                        getStaticPortMethod.endControlFlow()	
                }
                if (vertexPort.value['direction'] == null || (vertexPort.value['direction'] != null && vertexPort.value['direction'] <= 0)) {
                        getStaticPortMethod.beginControlFlow('for ($T e: model.incomingEdgesOf(vertex))', ClassName.get('forsyde.io.java.core', 'Edge'))
                        getStaticPortMethod.beginControlFlow("if (e.targetPort.orElse(\"\").equals(\"" + vertexPort.key + "\"))")
                        // this decides for every iteration if first found is good or if a list is being built.
                        if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                            getStaticPortMethod.addStatement('outList.add(e.source)')
                        else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                            getStaticPortMethod.addStatement('outList.add(e.source)')
                        else
                            getStaticPortMethod.addStatement('return Optional.of(e.source)')
                        getStaticPortMethod.endControlFlow()	
                        getStaticPortMethod.endControlFlow()	
                }
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getStaticPortMethod.addStatement("return outList")
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getStaticPortMethod.addStatement("return outList")
                else
                    getStaticPortMethod.addStatement("return Optional.empty()")
                // getStaticPortMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexPort.key + "\"))")
                // getStaticPortMethod.addStatement('return Optional.of((' + metaToJavaType(vertexPort.value).toString() + ") vertex.properties.get(\"" + vertexPort.key + "\"))")
                // getStaticPortMethod.nextControlFlow('else')
                // getStaticPortMethod.endControlFlow()
                acessorClass.addMethod(getStaticPortMethod.build())
                def getPortMethod = MethodSpec.methodBuilder('get' + toCamelCase(vertexPort.key + 'Port', true))
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(ClassName.get('forsyde.io.java.core', 'ForSyDeModel'), "model")
                if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                    getPortMethod.returns(arrayType)
                else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                    getPortMethod.returns(setType)
                else
                    getPortMethod.returns(optionalOut)
                getPortMethod.addStatement("return " + getStaticPortName + "(model, this)")
                acessorClass.addMethod(getPortMethod.build())
            }
            // this takes care of all the upper hierarchy of traits
            for (traitName in superIterator) {
				def superCurrentTrait = model['vertexTraits'][traitName]
				if (superCurrentTrait != null) {
					for(vertexProp in superCurrentTrait['required_properties']) {
						// accessGenerated.add(vertexProp.key)
                        def getPropName = 'get' + toCamelCase(vertexProp.key, true)
                        def getStaticPropName = 'staticGet' + toCamelCase(vertexProp.key, true)
						def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), metaToJavaType(vertexProp.value))
						def getPropMethod = MethodSpec.methodBuilder(getPropName)
							.addModifiers(Modifier.PUBLIC)
							// .addParameter(ClassName.get('forsyde.io.java.core', 'Vertex'), "vertex")
							.returns(metaToJavaType(vertexProp.value))
						// getPropMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexProp.key + "\"))")
						// getPropMethod.addStatement('return Optional.of((' + metaToJavaType(vertexProp.value).toString() + ") vertex.properties.get(\"" + vertexProp.key + "\"))")
						// getPropMethod.nextControlFlow('else')
                        // println(superCurrentTrait)
						getPropMethod.addStatement('return $T.' + getStaticPropName  + '(this)', ClassName.get('forsyde.io.java.typed.prototypes', traitName))
						// getPropMethod.endControlFlow()
						acessorClass.addMethod(getPropMethod.build())
					}
                    // port acessors are generated depending in the multiplicity of their connections and possible directions
					for(vertexPort in superCurrentTrait['required_ports']) {
						// accessGenerated.add(vertexPort.key)
						def vertexClass = ClassName.get('forsyde.io.java.core', 'Vertex')
                        def optionalOut = ParameterizedTypeName.get(ClassName.get(Optional.class), vertexClass)
						def listOut = ParameterizedTypeName.get(ClassName.get(List.class), vertexClass)
						def setOut = ParameterizedTypeName.get(ClassName.get(Set.class), vertexClass)
                        def arrayType = ParameterizedTypeName.get(ClassName.get(ArrayList.class), vertexClass)
                        def setType = ParameterizedTypeName.get(ClassName.get(HashSet.class), vertexClass)
                        def getPortName = 'get' + toCamelCase(vertexPort.key + 'Port', true)
                        def getStaticPortName = 'staticGet' + toCamelCase(vertexPort.key + 'Port', true)
						def getPortMethod = MethodSpec.methodBuilder(getPortName)
							.addModifiers(Modifier.PUBLIC)
							.addParameter(ClassName.get('forsyde.io.java.core', 'ForSyDeModel'), "model")
							// .addParameter(vertexClass, "vertex")
                        if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "ordered")
                            getPortMethod.returns(arrayType)
                        else if (vertexPort.value["multiple"] != null && vertexPort.value["multiple"] == "unordered")
                            getPortMethod.returns(setType)
                        else
                            getPortMethod.returns(optionalOut)
                        getPortMethod.addStatement('return $T.' + getStaticPortName + '(model, this)', ClassName.get('forsyde.io.java.typed.prototypes', traitName))
						// getPortMethod.beginControlFlow("if (vertex.properties.containsKey(\"" + vertexPort.key + "\"))")
						// getPortMethod.addStatement('return Optional.of((' + metaToJavaType(vertexPort.value).toString() + ") vertex.properties.get(\"" + vertexPort.key + "\"))")
						// getPortMethod.nextControlFlow('else')
						// getPortMethod.endControlFlow()
						acessorClass.addMethod(getPortMethod.build())
					}
				}
            }
        }
		def conformsMethod = MethodSpec
			.methodBuilder('conforms')
			.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
			.addParameter(ClassName.get('forsyde.io.java.core', 'Vertex'), 'vertex')
			.returns(ClassName.get(Boolean.class))
        conformsMethod.addStatement('return vertex.vertexTraits.contains($T.' + vertexTrait.key + ')', ClassName.get('forsyde.io.java.core', "VertexTrait"))
        acessorClass.addMethod(conformsMethod.build())
        def fileStr = JavaFile.builder('forsyde.io.java.typed.prototypes', acessorClass.build())
        file('src-gen/main/java/forsyde/io/java/typed/prototypes').mkdirs()
        file('src-gen/main/java/forsyde/io/java/typed/prototypes/' + className + '.java').text = fileStr.build()
    }
// write down these nice generated enums
}
